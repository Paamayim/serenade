# Globals Information

## Data Structures

~~~ { .c }
typedef struct {
    enum msg_type_t type;
    char ctrl;
    int dest, src;

    msg_envelope_t *next;
    uint32_t tick;

    enum mem_type_t memory_type;
    size_t len;
} msg_header_t;
~~~

The $msg\_header\_t$ describes the entire metadata of a message, including routing information, payload size, and state of memory-managedness. It is separate from the $msg\_envelope\_t$ type as an implementation detail to ensure that a message is exactly the same length as a memory block. The fields of $msg\_header\_t$ are used as follows:

- **type**: an enum identifying the type of message. May be one of the following values: *USER_MSG, SYSTEM_MSG, ~~CMD_REGISTER_MSG~~, ~~CMD_NOTIFY_MSG~~, ~~CMD_HOTKEY_MSG~~*, although it is recommended only the first two be used directly by non-system-code.
- **ctrl**: an extra byte of metadata, intended to distinguish between different subtypes of message types. User-code may use this field for whatever purpose it find [sic] useful.
- **~~dest~~**: the pid of the recipient process.
- **~~src~~**: the pid of the sending process.
- **~~next~~**: a pointer to the next message in the mailbox queue.
- **~~tick~~**: an internal representation of when to send this message.
- **~~memory_type~~**: a value representing whether or not this message employs regular memory management semantics.
- **len**: intended to describe the length of the data payload.


~~~ { .c }
#define MAX_MESSAGE_LENGTH (MMU_BLOCK_SIZE - sizeof(msg_header_t))
typedef struct {
    msg_header_t header;
    char data[MAX_MESSAGE_LENGTH];
} msg_envelope_t;
~~~

$msg\_envelope\_t$ is the actual message structure. It is designed to be perfectly aligned in memory blocks, and made of up the following fields:

- **header**: metadata for the message.
- **data**: a character array representing the message payload. This pointer may be cast to other structures for usability concerns.

The global define $MAX\_MESSAGE\_LENGTH$ is the maximum payload size per message.

## Functions

### Command Subsystem

~~~ { .c }
void cmd_init(void);
~~~

Initializes the command subsystem. This function must be called before any other command functions.

~~~ { .c }
void cmd_register(const char* tag);
~~~

Registers the endpoint of a command to the calling process. Henceforth, the calling process will receive $CMD\_NOTIFY\_MSG$ messages from the command subsystem, with message payloads consisting of "%<tag> <arguments>". $tag$ should not contain a space, as these are used internall as argument separators.

~~~ { .c }
char* cmd_parse(char* payload);
~~~

Replaces the first space in $payload$ with a *NULL* byte, and returns the next character. This helper function is useful for parsing command arguments out of message payloads.


### Error Subsystem

~~~ { .c }
const char *err_lookup(error_t err);
~~~

Returns a human-readable representation of an error thrown by any other subsystem.

### Memory Management Subsystem

~~~ { .c }
void mmu_init(void);
~~~

Initializes the memory management subsystem. This function must be called before any other mmu functions are, or *Bad Things* will happen and hard faults will likely occur.

~~~ { .c }
int mmu_can_alloc_mem(void);
~~~

Returns *true* if there are allocatable memory blocks.

~~~ { .c }
void *s_request_memory_block(void);
~~~

Returns a pointer to an address in memory of size $MMU\_BLOCK\_SIZE$. If no memory blocks are free, this function will block until one has been returned to the system.

~~~ { .c }
int s_release_memory_block(void *);
~~~

Frees a memory block so that it may be reused by other processes. Most system processes will automatically call this function on any messages passed to them, unless the message block is explicitly set as having user-managed memory policy.

### Messaging Subsystem

~~~ { .c }
msg_envelope_t *alloc_message(bool managed);
~~~

A helper function around $s\_request\_memory\_block$ which initializes the memory as a message and sets whether or not the message should be automatically managed by system processes.

~~~ { .c }
void free_message(void *pmsg);
~~~

Conditionally calls $s_release_memory_block$ if and only if the message is not marked as user managed memory.

~~~ { .c }
int send_message(int pid, void *msg);
~~~

Sends a $msg\_envelope\_t*$ msg to process $pid$. This function will pre-empt if the recipient process is waiting for a message and has higher priority than the current process.

~~~ { .c }
int send_kernel_message(int dest, int src, void *pmsg);
~~~

Sends a message in kernel mode to process $dest$, appearing to come from process $src$. Messages sent in kernel mode will never pre-empt, and are thus safe to send in interrupt contexts.

~~~ { .c }
int delayed_send(int pid, void *msg, uint32_t delay);
~~~

Sends a message to process $pid$ after $delay$ milliseconds.

~~~ { .c }
void *receive_message(int *sender);
~~~

Returns a pointer to a $msg\_envelope\_t$ that was previously sent to the current process. If no such message has been sent, this function will block until such time. $sender$ is an output parameter, whose value will be changed to the sending pid of the message. $sender$ may be set to *NULL* if no such behavior is required.

### Process Subsystem

~~~ { .c }
void proc_init(void);
~~~

Initializes the process subsystem. This function is responsible for setting up the default processes.

~~~ { .c }
int proc_get_pid(void);
~~~

Returns the pid of the currently running process.

~~~ { .c }
int proc_is_valid_pid(int pid);
~~~

Returns *true* if and only if $pid$ is a valid pid.

~~~ { .c }
int release_processor(void);
~~~

Relinquishes control of the processor, so other processes may run.

~~~ { .c }
int set_priority(priority_t priority, int pid);
~~~

Sets the priority of process $pid$ to $priority$.

~~~ { .c }
priority_t get_priority(int pid);
~~~

Returns the priority of process $pid$, or -1 if no such process exists.

### Timer Subsystem

~~~ { .c }
void timer_init(void);
~~~

Initializes the timer subsystem. Without this call, subsequent $delayed\_send$ messages will fail to propagate.

## Constants

~~~ { .c }
#define CRT_DISPLAY_PID 11
#define CMD_DECODER_PID 12
#define HOTKEY_PROC 13
~~~