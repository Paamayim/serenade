# Globals Information

## Data Structures

~~~ { .c }
typedef struct {
    enum msg_type_t type;
    char ctrl;
    int dest, src;

    msg_envelope_t *next;
    uint32_t tick;

    enum mem_type_t memory_type;
    size_t len;
} msg_header_t;
~~~

The $msg\_header\_t$ describes the entire metadata of a message, including routing information, payload size, and state of memory-managedness. It is separate from the $msg\_envelope\_t$ type as an implementation detail to ensure that a message is exactly the same length as a memory block. The fields of $msg\_header\_t$ are used as follows:

- **type**: an enum identifying the type of message. May be one of the following values: *USER_MSG, SYSTEM_MSG, ~~CMD_REGISTER_MSG~~, ~~CMD_NOTIFY_MSG~~, ~~CMD_HOTKEY_MSG~~*, although it is recommended only the first two be used directly by non-system-code.
- **ctrl**: an extra byte of metadata, intended to distinguish between different subtypes of message types. User-code may use this field for whatever purpose it find [sic] useful.
- **~~dest~~**: the pid of the recipient process.
- **~~src~~**: the pid of the sending process.
- **~~next~~**: a pointer to the next message in the mailbox queue.
- **~~tick~~**: an internal representation of when to send this message.
- **~~memory_type~~**: a value representing whether or not this message employs regular memory management semantics.
- **len**: intended to describe the length of the data payload.


~~~ { .c }
#define MAX_MESSAGE_LENGTH (MMU_BLOCK_SIZE - sizeof(msg_header_t))
typedef struct {
    msg_header_t header;
    char data[MAX_MESSAGE_LENGTH];
} msg_envelope_t;
~~~

$msg\_envelope\_t$ is the actual message structure. It is designed to be perfectly aligned in memory blocks, and made of up the following fields:

- **header**: metadata for the message.
- **data**: a character array representing the message payload. This pointer may be cast to other structures for usability concerns.

The global define $MAX\_MESSAGE\_LENGTH$ is the maximum payload size per message.

## Functions

### Command Subsystem

~~~ { .c }
void cmd_init(void);
void cmd_register(const char* tag);
char* cmd_parse(char* c);
~~~

### Error Subsystem

~~~ { .c }
const char *err_lookup(error_t err);
~~~

### Memory Management Subsystem

~~~ { .c }
void mmu_init(void);
int mmu_can_alloc_mem(void);

void *s_request_memory_block(void);
int s_release_memory_block(void *);
~~~

### Messaging Subsystem

~~~ { .c }
msg_envelope_t *alloc_message(bool managed);
void free_message(void *pmsg);

int send_message(int pid, void *msg);
int send_kernel_message(int dest, int src, void *pmsg);
int delayed_send(int pid, void *msg, uint32_t delay);

void *receive_message(int *sender);
~~~

### Process Subsystem

~~~ { .c }
void proc_init(void);

int proc_get_pid(void);
int proc_is_valid_pid(int pid);

int release_processor(void);
int proc_set_msg_blocked(int pid, int block);

int set_priority(int, int);
int get_priority(int);
~~~

### Timer Subsystem

~~~ { .c }
void timer_init(void);
~~~

## Constants

~~~ { .c }
#define PROC_NULL_PID 0

#define UPROC_PONG1_PID 1
#define UPROC_PONG2_PID 2

#define PROCA_PID 7
#define PROCB_PID 8
#define PROCC_PID 9

#define PROC_CLOCK_PID 10

#define CRT_DISPLAY_PID 11
#define CMD_DECODER_PID 12
#define HOTKEY_PROC 13

~~