# Globals Information

## Data Structures

~~~ { .c }
typedef struct {
    enum msg_type_t type;
    char ctrl;
    int dest, src;

    msg_envelope_t *next;
    uint32_t tick;

    enum mem_type_t memory_type;
    size_t len;
} msg_header_t;
~~~

The $msg\_header\_t$ describes the entire metadata of a message, including routing information, payload size, and state of memory-managedness. It is separate from the $msg\_envelope\_t$ type as an implementation detail to ensure that a message is exactly the same length as a memory block. The fields of $msg\_header\_t$ are used as follows:

- **type**: an enum identifying the type of message. May be one of the following values: *USER_MSG, SYSTEM_MSG, ~~CMD_REGISTER_MSG~~, ~~CMD_NOTIFY_MSG~~, ~~CMD_HOTKEY_MSG~~*, although it is recommended only the first two be used directly by non-system-code.
- **ctrl**: an extra byte of metadata, intended to distinguish between different subtypes of message types. User-code may use this field for whatever purpose it find [sic] useful.
- **~~dest~~**: the pid of the recipient process.
- **~~src~~**: the pid of the sending process.
- **~~next~~**: a pointer to the next message in the mailbox queue.
- **~~tick~~**: an internal representation of when to send this message.
- **~~memory_type~~**: a value representing whether or not this message employs regular memory management semantics.
- **len**: intended to describe the length of the data payload.


~~~ { .c }
#define MAX_MESSAGE_LENGTH (MMU_BLOCK_SIZE - sizeof(msg_header_t))
typedef struct {
    msg_header_t header;
    char data[MAX_MESSAGE_LENGTH];
} msg_envelope_t;
~~~

$msg\_envelope\_t$ is the actual message structure. It is designed to be perfectly aligned in memory blocks, and made of up the following fields:

- **header**: metadata for the message.
- **data**: a character array representing the message payload. This pointer may be cast to other structures for usability concerns.

The global define $MAX\_MESSAGE\_LENGTH$ is the maximum payload size per message.

## Functions

### Command Subsystem

~~~ { .c }
void cmd_init(void);
~~~

Initializes the command subsystem. This function must be called before any other command functions.

~~~ { .c }
void cmd_register(const char* tag);
~~~

Registers the endpoint of a command to the calling process. Henceforth, the calling process will receive $CMD\_NOTIFY\_MSG$ messages from the command subsystem, with message payloads consisting of "%<tag> <arguments>". $tag$ should not contain a space, as these are used internall as argument separators.

~~~ { .c }
char* cmd_parse(char* payload);
~~~

Replaces the first space in $payload$ with a *NULL* byte, and returns the next character. This helper function is useful for parsing command arguments out of message payloads.


### Error Subsystem

~~~ { .c }
const char *err_lookup(error_t err);
~~~

Returns a human-readable representation of an error thrown by any other subsystem.

### Memory Management Subsystem

~~~ { .c }
void mmu_init(void);
~~~

Initializes the memory management subsystem. This function must be called before any other mmu functions are, or *Bad Things* will happen and hard faults will likely occur.

~~~ { .c }
int mmu_can_alloc_mem(void);
~~~

Returns *true* if there are allocatable memory blocks.

~~~ { .c }
void *s_request_memory_block(void);
~~~

Returns a pointer to an address in memory of size $MMU\_BLOCK\_SIZE$. If no memory blocks are free, this function will block until one has been returned to the system.

~~~ { .c }
int s_release_memory_block(void *);
~~~

Frees a memory block so that it may be reused by other processes. Most system processes will automatically call this function on any messages passed to them, unless the message block is explicitly set as having user-managed memory policy.

### Messaging Subsystem

~~~ { .c }
msg_envelope_t *alloc_message(bool managed);
void free_message(void *pmsg);

int send_message(int pid, void *msg);
int send_kernel_message(int dest, int src, void *pmsg);
int delayed_send(int pid, void *msg, uint32_t delay);

void *receive_message(int *sender);
~~~

### Process Subsystem

~~~ { .c }
void proc_init(void);

int proc_get_pid(void);
int proc_is_valid_pid(int pid);

int release_processor(void);
int proc_set_msg_blocked(int pid, int block);

int set_priority(int, int);
int get_priority(int);
~~~

### Timer Subsystem

~~~ { .c }
void timer_init(void);
~~~

## Constants

~~~ { .c }
#define PROC_NULL_PID 0

#define UPROC_PONG1_PID 1
#define UPROC_PONG2_PID 2

#define PROCA_PID 7
#define PROCB_PID 8
#define PROCC_PID 9

#define PROC_CLOCK_PID 10

#define CRT_DISPLAY_PID 11
#define CMD_DECODER_PID 12
#define HOTKEY_PROC 13
~~~