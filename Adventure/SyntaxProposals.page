# Better Scaffold Trees

## Purpose
Scaffold Trees exist to quickly lay out data hierarchies. They create helper objects as you index them, and call a callback when assigned to. This is useful when declaring data (currently adventure uses them for a room's scripted events), but quickly falls apart when the context calls for a *data structure*. Since in the background it is simply creating helper objects to maintain hierarchy, Lua can't tell when you actually want to use the data instead of just creating it. A simple hack is to overload the *__call* metamethod and append parens to a scaffold table to dereference it, but this is ugly and exceedingly (to coin a word) unluatic.

## Current Solution
Add a new derefence operator (*) and a new reassignment operator (=>). Despite these just being regular variables, add some semantic sugar to impress the fact that these aren't real lua objects, and that they can be hard to reason about.

~~~ { .lua }
-- get a local copy of the isOpen "pointer"
persist isOpen = state.meadow.isOpen
 -- value assignment. negate the value
isOpen => not *isOpen
-- dereference it
if *isOpen then
    -- pointer assignment. value isn't changed
    isOpen = state.cellar.isAlsoOpen
end
~~~

## Issues
We have introduced a lot of new syntax. Because the bank is backed by a ScaffoldTable, we are unable to do useful things with tables. These new operators aren't fully integrated, and will break in most use cases outside of what's shown here.

## Proposal
Have a new statement which predeclares any variables you might want to use, and imports them into the local scope. Use real tables from here on out.

~~~ { .lua }
affirm (save.meadow) { isOpen, wasOpen(true), chessboard.queenPosition(2, 3) }
~~~

This example will create the following global variables *save.meadow.isOpen*, *save.meadow.wasOpen = true*, *save.meadow.chessboard.queenPosition = 2,3*. Furthermore, it will create the following local variables *isOpen*, *wasOpen*, *chessboard.queenPosition*. The identifiers in braces indicate relevant variables,  while the identifier in parenthesis indicates a prefix in the global table (but not in the locals).

## Proposal
Add a new affirm operator (->) which will create intermediate tables should they not exist.
~~~ { .lua }
-- The following pairs of lines are equivalent
foo->bar = true
if not foo then foo = { } end; foo.bar = true

print(foo->bar->baz)
print(foo and foo.bar and foo.bar.baz)
~~~